{"version":3,"file":"index.js","sources":["../../src/utils/getInnerSize.ts","../../src/useEventListener.ts","../../node_modules/style-inject/dist/style-inject.es.js","../../src/Gutter.tsx","../../src/state/reducer.actions.ts","../../src/index.tsx","../../src/utils/getGutterSize.ts","../../src/state/reducer.ts","../../src/utils/flattenChildren.ts"],"sourcesContent":["import { SplitDirection } from '../index';\n\nexport default function getInnerSize(direction: SplitDirection, element: HTMLElement) {\n  // Returns undefined if parent element has no layout yet.\n  // Or if the parent has no size.\n\n  const computedStyle = getComputedStyle(element);\n  if (!computedStyle) return;\n\n  let size = direction === SplitDirection.Horizontal ? element.clientWidth : element.clientHeight;\n\n  if (size === 0) return;\n\n  if (direction === SplitDirection.Horizontal) {\n    size -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  } else {\n    size -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n  }\n\n  return size;\n}\n","import { useEffect } from 'react';\n\nfunction useEventListener(event: string, handler: (event: any) => void, deps: any[] = []) {\n  useEffect(() => {\n    window.addEventListener(event, handler);\n    return () => window.removeEventListener(event, handler);\n\n// eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [event, handler, ...deps]);\n}\n\nexport default useEventListener;\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","import React from 'react';\nimport { SplitDirection, GutterTheme } from './index';\n\ninterface GutterProps {\n  className?: string;\n  theme: GutterTheme;\n  draggerClassName?: string;\n  direction?: SplitDirection;\n  onMouseDown?: (e: any) => void;\n}\n\nconst Gutter = React.forwardRef<HTMLDivElement, GutterProps>((\n  {\n    className,\n    theme,\n    draggerClassName,\n    direction = SplitDirection.Vertical,\n    onMouseDown,\n  },\n  ref,\n) => {\n  const containerClass = `__dbk__gutter ${direction} ${className || theme}`;\n  const draggerClass = `__dbk__dragger ${direction} ${draggerClassName || theme}`;\n\n  return (\n    <div\n      className={containerClass}\n      ref={ref}\n      dir={direction}\n      onMouseDown={onMouseDown}\n    >\n      <div className={draggerClass}/>\n    </div>\n  );\n});\n\nexport default Gutter;\n\n","import type { SplitDirection } from 'index';\n\nexport enum ActionType {\n  SetIsReadyToCompute,\n  CreatePairs,\n  CalculateSizes,\n  StartDragging,\n  StopDragging,\n}\n\nexport interface SetIsReadyToCompute {\n  type: ActionType.SetIsReadyToCompute;\n  payload: {\n    isReady: boolean,\n  };\n}\n\nexport interface CreatePairs {\n  type: ActionType.CreatePairs;\n  payload: {\n    direction: SplitDirection,\n    children: HTMLElement[],\n    gutters: HTMLElement[],\n  };\n}\n\nexport interface CalculateSizes {\n  type: ActionType.CalculateSizes;\n  payload: {\n    direction: SplitDirection,\n    gutterIdx: number;\n  };\n}\n\nexport interface StartDragging {\n  type: ActionType.StartDragging;\n  payload: {\n    gutterIdx: number;\n  };\n}\n\ninterface StopDragging {\n  type: ActionType.StopDragging;\n}\n\nexport type Action = SetIsReadyToCompute\n  | CreatePairs\n  | CalculateSizes\n  | StartDragging\n  | StopDragging;\n\n\n","import React, {\n  useEffect,\n  useReducer,\n  useRef,\n} from 'react';\n\nimport './index.css';\nimport getInnerSize from './utils/getInnerSize';\nimport useEventListener from './useEventListener';\nimport Gutter from './Gutter';\nimport { ActionType } from './state/reducer.actions';\nimport reducer, { State } from './state/reducer';\nimport getGutterSizes from './utils/getGutterSize';\nimport flattenChildren from './utils/flattenChildren';\n\nexport enum SplitDirection {\n  Horizontal = 'Horizontal',\n  Vertical = 'Vertical',\n}\n\nexport enum GutterTheme {\n  Light = 'Light',\n  Dark = 'Dark',\n}\n\nconst DefaultMinSize = 16;\nconst DefaultMaxSize = Number.MAX_VALUE;\n\nfunction getMousePosition(dir: SplitDirection, e: MouseEvent) {\n  if (dir === SplitDirection.Horizontal) return e.clientX;\n  return e.clientY;\n}\n\nfunction getCursorIcon(dir: SplitDirection) {\n  if (dir === SplitDirection.Horizontal) return 'col-resize';\n  return 'row-resize';\n}\n\n/*\nconst stateInit: State = (direction: SplitDirection = SplitDirection.Horizontal) => ({\n  direction,\n  isDragging: false,\n  pairs: [],\n});\n*/\n\nconst initialState: State = {\n  isReady: false,\n  isDragging: false,\n  pairs: [],\n}\n\ninterface SplitProps {\n  direction?: SplitDirection;\n  minWidths?: number[]; // In pixels.\n  minHeights?: number[]; // In pixels.\n  maxWidths?: number[]; // In pixels.\n  maxHeights?: number[]; // In pixels.\n  initialSizes?: number[]; // In percentage.\n  gutterTheme?: GutterTheme;\n  gutterClassName?: string;\n  draggerClassName?: string;\n  children?: React.ReactNode;\n  onResizeStarted?: (pairIdx: number) => void;\n  onResizeFinished?: (pairIdx: number, newSizes: number[]) => void;\n  classes?: string[];\n}\n\nfunction Split({\n  direction = SplitDirection.Horizontal,\n  minWidths = [],\n  minHeights = [],\n  maxWidths = [],\n  maxHeights = [],\n  initialSizes,\n  gutterTheme = GutterTheme.Dark,\n  gutterClassName,\n  draggerClassName,\n  children: reactChildren,\n  onResizeStarted,\n  onResizeFinished,\n  classes = [],\n}: SplitProps) {\n  const children = flattenChildren(reactChildren)\n\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  const containerRef = useRef<HTMLDivElement>(null)\n  const childRefs = useRef<HTMLElement[]>([]);\n  const gutterRefs = useRef<HTMLElement[]>([]);\n  // We want to reset refs on each re-render so they don't contain old references.\n  childRefs.current = [];\n  gutterRefs.current = [];\n\n  // Helper dispatch functions.\n  const setIsReadyToCompute = React.useCallback((isReady: boolean) => {\n    dispatch({\n      type: ActionType.SetIsReadyToCompute,\n      payload: { isReady },\n    })\n  }, [])\n\n  const startDragging = React.useCallback((direction: SplitDirection, gutterIdx: number) => {\n    dispatch({\n      type: ActionType.StartDragging,\n      payload: { gutterIdx },\n    });\n\n    const pair = state.pairs[gutterIdx];\n    onResizeStarted?.(pair.idx)\n\n    // Disable selection.\n    pair.a.style.userSelect = 'none';\n    pair.b.style.userSelect = 'none';\n\n    // Set the mouse cursor.\n    // Must be done at multiple levels, nut just for a gutter.\n    // The mouse cursor might move outside of the gutter element.\n    pair.gutter.style.cursor = getCursorIcon(direction);\n    pair.parent.style.cursor = getCursorIcon(direction);\n    document.body.style.cursor = getCursorIcon(direction);\n  }, [state.pairs]);\n\n  const stopDragging = React.useCallback(() => {\n    dispatch({\n      type: ActionType.StopDragging,\n    });\n\n    // The callback receives an index of the resized pair and new sizes of all child elements.\n    const allSizes: number[] = [];\n    for (let idx = 0; idx < state.pairs.length; idx++) {\n      const pair = state.pairs[idx];\n      const parentSize = getInnerSize(direction, pair.parent);\n      if (parentSize === undefined) throw new Error(`Cannot call the 'onResizeFinished' callback - parentSize is undefined`);\n      if (pair.gutterSize === undefined) throw new Error(`Cannot call 'onResizeFinished' callback - gutterSize is undefined`);\n\n      const isFirst = idx === 0;\n      const isLast = idx === state.pairs.length - 1;\n\n      const aSize = pair.a.getBoundingClientRect()[direction === SplitDirection.Horizontal ? 'width' : 'height'];\n      const { aGutterSize, bGutterSize } = getGutterSizes(pair.gutterSize, isFirst, isLast);\n      const aSizePct = ((aSize + aGutterSize) / parentSize) * 100;\n      allSizes.push(aSizePct);\n\n      if (isLast) {\n        const bSize = pair.b.getBoundingClientRect()[direction === SplitDirection.Horizontal ? 'width' : 'height'];\n        const bSizePct = ((bSize + bGutterSize) / parentSize) * 100;\n        allSizes.push(bSizePct);\n      }\n    }\n\n    if (state.draggingIdx === undefined) throw new Error(`Could not reset cursor and user-select because 'state.draggingIdx' is undefined`);\n    const pair = state.pairs[state.draggingIdx];\n    onResizeFinished?.(pair.idx, allSizes);\n\n    // Disable selection.\n    pair.a.style.userSelect = '';\n    pair.b.style.userSelect = '';\n\n    // Set the mouse cursor.\n    // Must be done at multiple levels, not just for a gutter.\n    // The mouse cursor might move outside of the gutter element.\n    pair.gutter.style.cursor = '';\n    pair.parent.style.cursor = '';\n    document.body.style.cursor = '';\n  }, [state.draggingIdx, state.pairs, direction]);\n\n  const calculateSizes = React.useCallback((direction: SplitDirection, gutterIdx: number) => {\n    dispatch({\n      type: ActionType.CalculateSizes,\n      payload: { direction, gutterIdx },\n    });\n  }, []);\n\n  const createPairs = React.useCallback((direction: SplitDirection, children: HTMLElement[], gutters: HTMLElement[]) => {\n    dispatch({\n      type: ActionType.CreatePairs,\n      payload: { direction, children, gutters },\n    });\n  }, []);\n  /////////\n\n  // This method is called on the initial render.\n  // It iterates through the all children sets their initial sizes.\n  const setInitialSizes = React.useCallback((\n    direction: SplitDirection,\n    children: HTMLElement[],\n    gutters: HTMLElement[],\n    initialSizes?: number[],\n  ) => {\n    // All children must have common parent.\n    const parent = children[0].parentNode;\n    if (!parent) throw new Error(`Cannot set initial sizes - parent is undefined`);\n    const parentSize = getInnerSize(direction, parent as HTMLElement);\n    if (parentSize === undefined) throw new Error(`Cannot set initial sizes - parent has undefined size`);\n\n    children.forEach((c, idx) => {\n      const isFirst = idx === 0;\n      const isLast = idx === children.length - 1;\n\n      let gutterSize = 0\n      if (children.length > 1) {\n        const gutter = gutters[isLast ? idx-1 : idx];\n        let gutterSize = gutter.getBoundingClientRect()[direction === SplitDirection.Horizontal ? 'width' : 'height'];\n        gutterSize = isFirst || isLast ? gutterSize / 2 : gutterSize;\n      }\n\n      let calc: string;\n      if (initialSizes && idx < initialSizes.length)  {\n        calc = `calc(${initialSizes[idx]}% - ${gutterSize}px)`;\n      } else {\n        // '100 / children.length' makes all the children same wide.\n        calc = `calc(${100 / children.length}% - ${gutterSize}px)`;\n      }\n\n      if (direction === SplitDirection.Horizontal) {\n        c.style.width = calc;\n        // Reset the child wrapper's height because the direction could have changed.\n        c.style.height = '100%';\n      } else {\n        c.style.height = calc;\n        // Reset the child wrapper's width because the direction could have changed.\n        c.style.width = '100%';\n      }\n    });\n  }, []);\n\n  // Here we actually change the width of children.\n  // We convert the element's sizes into percentage\n  // and let the CSS 'calc' function do the heavy lifting.\n  // Size of 'pair.a' is same as 'offset'.\n  //\n  // For just 2 children total, the percentage adds up always to 100.\n  // For >2 children total, the percentage adds to less than 100.\n  // That's because a single gutter changes sizes of only the given pair of children.\n  // Each gutter changes size only of the two adjacent elements.\n  // -----------------------------------------------------------------------\n  // |                     |||                     |||                     |\n  // |       33.3%         |||        33.3%        |||       33.3%         |\n  // |                     |||                     |||                     |\n  // |                     |||                     |||                     |\n  // -----------------------------------------------------------------------\n  const adjustSize = React.useCallback((direction: SplitDirection, offset: number) => {\n    if (state.draggingIdx === undefined) throw new Error(`Cannot adjust size - 'draggingIdx' is undefined`);\n\n    const pair = state.pairs[state.draggingIdx];\n    if (pair.size === undefined) throw new Error(`Cannot adjust size - 'pair.size' is undefined`);\n    if (pair.gutterSize === undefined) throw new Error(`Cannot adjust size - 'pair.gutterSize' is undefined`);\n    const percentage = pair.aSizePct + pair.bSizePct;\n\n    const aSizePct = (offset / pair.size) * percentage;\n    const bSizePct = percentage - (offset / pair.size) * percentage;\n\n    const isFirst = state.draggingIdx === 0;\n    const isLast = state.draggingIdx === state.pairs.length - 1;\n    const { aGutterSize, bGutterSize } = getGutterSizes(pair.gutterSize, isFirst, isLast);\n\n    const aCalc = `calc(${aSizePct}% - ${aGutterSize}px)`;\n    const bCalc = `calc(${bSizePct}% - ${bGutterSize}px)`;\n    if (direction === SplitDirection.Horizontal) {\n      pair.a.style.width = aCalc;\n      pair.b.style.width = bCalc;\n    } else {\n      pair.a.style.height = aCalc;\n      pair.b.style.height = bCalc;\n    }\n  }, [state.draggingIdx, state.pairs, direction]);\n\n  const drag = React.useCallback((e: MouseEvent, direction: SplitDirection, minSizes: number[], maxSizes: number[]) => {\n    if (!state.isDragging) return\n    if (state.draggingIdx === undefined) throw new Error(`Cannot drag - 'draggingIdx' is undefined`);\n\n    const pair = state.pairs[state.draggingIdx];\n    if (pair.start === undefined) throw new Error(`Cannot drag - 'pair.start' is undefined`);\n    if (pair.size === undefined) throw new Error(`Cannot drag - 'pair.size' is undefined`);\n    if (pair.gutterSize === undefined) throw new Error(`Cannot drag - 'pair.gutterSize' is undefined`);\n\n    // 'offset' is the width of the 'a' element in a pair.\n    let offset = getMousePosition(direction, e) - pair.start;\n\n    // Limit the maximum size and the minimum size of resized children.\n\n    let aMinSize = DefaultMinSize;\n    let bMinSize = DefaultMinSize;\n    let aMaxSize = DefaultMaxSize;\n    let bMaxSize = DefaultMaxSize;\n    if (minSizes.length > state.draggingIdx) {\n      aMinSize = minSizes[state.draggingIdx];\n    }\n    if (minSizes.length >= state.draggingIdx + 1) {\n      bMinSize = minSizes[state.draggingIdx + 1];\n    }\n    if (maxSizes.length > state.draggingIdx) {\n      aMaxSize = maxSizes[state.draggingIdx];\n    }\n    if (maxSizes.length >= state.draggingIdx + 1) {\n      bMaxSize = maxSizes[state.draggingIdx + 1];\n    }\n\n    // TODO: We should check whether the parent is big enough\n    // to support these min sizes.\n    if (offset < pair.gutterSize + aMinSize) {\n      offset = pair.gutterSize + aMinSize;\n    }\n\n    if (offset >= pair.size - (pair.gutterSize + bMinSize)) {\n      offset = pair.size - (pair.gutterSize + bMinSize);\n    }\n    \n    if (offset > pair.gutterSize + aMaxSize) {\n      offset = pair.gutterSize + aMaxSize;\n    }\n\n    if (offset <= pair.size - (pair.gutterSize + bMaxSize)) {\n      offset = pair.size - (pair.gutterSize + bMaxSize);\n    }\n\n    adjustSize(direction, offset);\n  }, [state.isDragging, state.draggingIdx, state.pairs, adjustSize]);\n\n  function handleGutterMouseDown(gutterIdx: number, e: MouseEvent) {\n    e.preventDefault();\n    calculateSizes(direction, gutterIdx);\n    startDragging(direction, gutterIdx);\n  }\n\n  useEventListener('mouseup', () => {\n    if (!state.isDragging) return;\n    if (state.draggingIdx === undefined)\n      throw new Error(`Cannot calculate sizes after dragging = 'state.draggingIdx' is undefined`);\n    calculateSizes(direction, state.draggingIdx);\n    stopDragging();\n  }, [state.isDragging, stopDragging]);\n\n  useEventListener('mousemove', (e: MouseEvent) => {\n    if (!state.isDragging) return;\n    drag(e, direction, direction === SplitDirection.Horizontal ? minWidths : minHeights, direction === SplitDirection.Horizontal ? maxWidths : maxHeights);\n  }, [direction, state.isDragging, drag, minWidths, minHeights, maxWidths, maxHeights]);\n\n  // This makes sure that Splitter properly re-renders if parent's size changes dynamically.\n  useEffect(function watchParentSize() {\n    if (!containerRef.current) return\n    const el = containerRef.current.parentElement\n\n    // Splitter must have a parent element. In the most trivial example it's either <body> or <html>.\n    if (!el) return\n\n    // TODO: Potential performance issue!\n    // When nesting Splitters the `observer` is registered for each nesting \"level\".\n    // Splitter's parent element is another Splitter in the nesting use case.\n    const observer = new ResizeObserver(() => {\n      const style = getComputedStyle(el)\n      const size = direction === SplitDirection.Horizontal ? el.clientWidth : el.clientHeight\n      const isReady = !!style && !!size\n      setIsReadyToCompute(isReady)\n    })\n    observer.observe(el)\n\n    return () => {\n      observer.disconnect()\n    }\n  }, [\n    containerRef.current,\n    direction,\n  ])\n\n  // Initial setup, runs every time the child views change.\n  useEffect(function initialSetup() {\n    if (!state.isReady) return\n    // By the time first useEffect runs refs should be already set, unless something really bad happened.\n    if (!childRefs.current || !gutterRefs.current) {\n      throw new Error(`Cannot create pairs - either variable 'childRefs' or 'gutterRefs' is undefined`);\n    }\n\n    // Don't create pairs if there's only one child.\n    if (children.length <= 1) {\n      setInitialSizes(direction, childRefs.current, gutterRefs.current, initialSizes);\n    } else {\n      setInitialSizes(direction, childRefs.current, gutterRefs.current, initialSizes);\n      createPairs(direction, childRefs.current, gutterRefs.current);\n    }\n\n  }, [\n    reactChildren,\n    state.isReady,\n    direction,\n    setInitialSizes,\n    createPairs,\n    initialSizes,\n  ]);\n\n  function addRef(refs: typeof childRefs | typeof gutterRefs, el: any) {\n    if (!refs.current) throw new Error(`Can't add element to ref object - ref isn't initialized`);\n    if (el && !refs.current.includes(el)) {\n      refs.current.push(el);\n    }\n  }\n\n  return (\n    <div\n      className={'__dbk__container ' + `${direction}`}\n      ref={containerRef}\n    >\n      {state.isReady && children.map((c, idx) => (\n        <React.Fragment key={idx}>\n          <div\n            ref={el => addRef(childRefs, el)}\n            className={'__dbk__child-wrapper ' + (idx < classes.length ? classes[idx] : '')}\n          >{c}\n          </div>\n\n          {/* Gutter is between each two child views. */}\n          {idx < (children as React.ReactNodeArray).length - 1 &&\n            <Gutter\n              ref={el => addRef(gutterRefs, el)}\n              className={gutterClassName}\n              theme={gutterTheme}\n              draggerClassName={draggerClassName}\n              direction={direction}\n              onMouseDown={e => handleGutterMouseDown(idx, e)}\n            />\n          }\n        </React.Fragment>\n      ))}\n    </div>\n  );\n}\n\nexport type {\n  SplitProps\n}\nexport default Split;\n","export default function getGutterSizes(gutterSize: number, isFirst: boolean, isLast: boolean) {\n  let aGutterSize: number;\n  let bGutterSize: number;\n\n  if (isFirst) {\n    aGutterSize = gutterSize / 2;\n    bGutterSize = gutterSize;\n  } else if (isLast) {\n    aGutterSize = gutterSize;\n    bGutterSize = gutterSize / 2;\n  } else {\n    aGutterSize = gutterSize;\n    bGutterSize = gutterSize;\n  }\n\n  return { aGutterSize, bGutterSize };\n};\n","import { SplitDirection } from '../index';\nimport { Action, ActionType } from './reducer.actions';\nimport Pair from '../pair';\n\nimport getInnerSize from '../utils/getInnerSize';\nimport getGutterSizes from '../utils/getGutterSize';\n\nexport interface State {\n  isReady: boolean;\n\n  isDragging: boolean;\n  draggingIdx?: number; // Index of a gutter that is being dragged.\n\n  pairs: Pair[];\n}\n\nexport default function reducer(state: State, action: Action) {\n  switch (action.type) {\n    case ActionType.SetIsReadyToCompute: {\n      return {\n        ...state,\n        isReady: action.payload.isReady,\n      }\n    }\n    // -----------------------------------------------------------------------\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\n    // |             |                     |                  |              |\n    // |           pair 0                pair 1             pair 2           |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    case ActionType.CreatePairs: {\n      const { direction, children, gutters } = action.payload;\n\n      // All children must have common parent.\n      const parent = children[0].parentNode;\n      if (!parent) throw new Error(`Cannot create pairs - parent is undefined.`);\n      const parentSize = getInnerSize(direction, parent as HTMLElement);\n      if (parentSize === undefined) throw new Error(`Cannot create pairs - parent has undefined or zero size: ${parentSize}.`);\n\n      const pairs: Pair[] = [];\n      children.forEach((_, idx) => {\n        if (idx > 0) {\n          const a = children[idx-1];\n          const b = children[idx];\n          const gutter = gutters[idx-1];\n\n          const start = direction === SplitDirection.Horizontal\n            ? a.getBoundingClientRect().left\n            : a.getBoundingClientRect().top;\n\n          const end = direction === SplitDirection.Horizontal\n            ? b.getBoundingClientRect().right\n            : b.getBoundingClientRect().bottom;\n\n          const size = direction === SplitDirection.Horizontal\n            ? a.getBoundingClientRect().width + gutter.getBoundingClientRect().width + b.getBoundingClientRect().width\n            : a.getBoundingClientRect().height + gutter.getBoundingClientRect().height + b.getBoundingClientRect().height\n\n          const gutterSize = direction === SplitDirection.Horizontal\n            ? gutter.getBoundingClientRect().width\n            : gutter.getBoundingClientRect().height;\n\n          const pair: Pair = {\n            idx: idx-1,\n            // TODO: Do we need to have a reference to the whole elements? Aren't indexes enough?\n            a,\n            b,\n            gutter,\n            parent: parent as HTMLElement,\n            start,\n            end,\n            size,\n            gutterSize,\n            // At the start, all elements has the same width.\n            aSizePct: 100 / children.length,\n            bSizePct: 100 / children.length,\n          };\n\n          pairs.push(pair);\n        }\n      });\n\n      return {\n        ...state,\n        pairs,\n      };\n    }\n    case ActionType.StartDragging: {\n      const { gutterIdx } = action.payload;\n      return {\n        ...state,\n        isDragging: true,\n        draggingIdx: gutterIdx,\n      };\n    }\n    case ActionType.StopDragging: {\n      return {\n        ...state,\n        isDragging: false,\n      };\n    }\n    // Recalculates the stored sizes based on the actual elements' sizes.\n    case ActionType.CalculateSizes: {\n      // We need to calculate sizes only for the pair\n      // that has the moved gutter.\n      const { direction, gutterIdx } = action.payload;\n      const pair = state.pairs[gutterIdx];\n\n      const parentSize = getInnerSize(direction, pair.parent);\n      if (!parentSize) throw new Error(`Cannot calculate sizes - 'pair.parent' has undefined or zero size.`);\n\n      const gutterSize = pair.gutter[direction === SplitDirection.Horizontal ? 'clientWidth' : 'clientHeight'];\n\n      const isFirst = gutterIdx === 0;\n      const isLast = gutterIdx === state.pairs.length - 1;\n      const { aGutterSize, bGutterSize } = getGutterSizes(gutterSize, isFirst, isLast);\n\n      let start: number;\n      let end: number;\n      let size: number;\n      let aSizePct: number;\n      let bSizePct: number;\n\n      if (direction === SplitDirection.Horizontal) {\n        start = pair.a.getBoundingClientRect().left;\n\n        end = pair.b.getBoundingClientRect().right;\n\n        aSizePct = ((pair.a.getBoundingClientRect().width + aGutterSize) / parentSize) * 100;\n        bSizePct = ((pair.b.getBoundingClientRect().width + bGutterSize) / parentSize) * 100;\n\n        size =\n          pair.a.getBoundingClientRect().width +\n          aGutterSize +\n          bGutterSize +\n          pair.b.getBoundingClientRect().width;\n      } else {\n        start = pair.a.getBoundingClientRect().top;\n\n        end = pair.b.getBoundingClientRect().bottom;\n\n        aSizePct = ((pair.a.getBoundingClientRect().height + aGutterSize) / parentSize) * 100;\n        bSizePct = ((pair.b.getBoundingClientRect().height + bGutterSize) / parentSize) * 100;\n\n        size =\n          pair.a.getBoundingClientRect().height +\n          aGutterSize +\n          bGutterSize +\n          pair.b.getBoundingClientRect().height;\n      }\n\n      state.pairs[gutterIdx] = {\n        ...pair,\n        start,\n        end,\n        size,\n        aSizePct,\n        bSizePct,\n        gutterSize,\n      };\n\n      return {\n        ...state\n      };\n    }\n    default:\n      return state;\n  }\n}\n\n","// Taken from https://github.com/grrowl/react-keyed-flatten-children\n\n/* Returns React children into an array, flattening fragments. */\nimport {\n  ReactNode,\n  ReactChild,\n  Children,\n  isValidElement,\n  cloneElement\n} from 'react';\nimport { isFragment } from 'react-is';\n\nexport default function flattenChildren(\n  children: ReactNode,\n  depth: number = 0,\n  keys: (string | number)[] = []\n): ReactChild[] {\n  return Children.toArray(children).reduce(\n    (acc: ReactChild[], node, nodeIndex) => {\n      if (isFragment(node)) {\n        acc.push.apply(\n          acc,\n          flattenChildren(\n            node.props.children,\n            depth + 1,\n            keys.concat(node.key || nodeIndex)\n          )\n        );\n      } else {\n        if (isValidElement(node)) {\n          acc.push(\n            cloneElement(node, {\n              key: keys.concat(String(node.key)).join('.')\n            })\n          );\n        } else if (typeof node === 'string' || typeof node === 'number') {\n          acc.push(node);\n        }\n      }\n      return acc;\n    },\n    []\n  );\n}\n"],"names":["getInnerSize","direction","element","computedStyle","getComputedStyle","size","SplitDirection","Horizontal","clientWidth","clientHeight","parseFloat","paddingLeft","paddingRight","paddingTop","paddingBottom","useEventListener","event","handler","deps","useEffect","window","addEventListener","removeEventListener","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","Gutter","React","forwardRef","className","theme","draggerClassName","Vertical","onMouseDown","containerClass","draggerClass","_jsx","dir","ActionType","GutterTheme","getGutterSizes","gutterSize","isFirst","isLast","aGutterSize","bGutterSize","reducer","state","action","SetIsReadyToCompute","isReady","payload","CreatePairs","children","gutters","parent","parentNode","Error","parentSize","undefined","pairs","forEach","_","idx","a","b","gutter","start","getBoundingClientRect","left","top","end","right","bottom","width","height","pair","aSizePct","length","bSizePct","push","StartDragging","gutterIdx","isDragging","draggingIdx","StopDragging","CalculateSizes","flattenChildren","depth","keys","Children","toArray","reduce","acc","node","nodeIndex","isFragment","apply","props","concat","key","isValidElement","cloneElement","String","join","DefaultMaxSize","Number","MAX_VALUE","getCursorIcon","initialState","minWidths","minHeights","maxWidths","maxHeights","initialSizes","gutterTheme","Dark","gutterClassName","reactChildren","onResizeStarted","onResizeFinished","classes","dispatch","useReducer","containerRef","useRef","childRefs","gutterRefs","current","setIsReadyToCompute","useCallback","startDragging","userSelect","cursor","body","stopDragging","allSizes","aSize","calculateSizes","createPairs","setInitialSizes","c","calc","adjustSize","offset","percentage","aCalc","bCalc","drag","e","minSizes","maxSizes","clientX","clientY","getMousePosition","aMinSize","bMinSize","aMaxSize","bMaxSize","addRef","refs","el","includes","parentElement","observer","ResizeObserver","observe","disconnect","map","_jsxs","Fragment","preventDefault","handleGutterMouseDown"],"mappings":"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"}